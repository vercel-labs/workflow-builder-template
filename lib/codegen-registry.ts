/**
 * Codegen Registry (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * Contains auto-generated codegen templates for steps with stepHandler.
 * These templates are used when exporting workflows to standalone projects.
 *
 * Generated templates: 16
 */

/**
 * Auto-generated codegen templates
 * Maps action IDs to their generated export code templates
 */
export const AUTO_GENERATED_TEMPLATES: Record<string, string> = {
  "ai-gateway/generate-text": `import { createGateway, generateObject, generateText } from "ai";
import { z } from "zod";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateTextResult =
  | { success: true; text: string }
  | { success: true; object: Record<string, unknown> }
  | { success: false; error: string };

export type GenerateTextCoreInput = {
  aiModel?: string;
  aiPrompt?: string;
  aiFormat?: string;
  aiSchema?: string;
};

export async function generateTextStep(input: GenerateTextCoreInput): Promise<GenerateTextResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const modelId = input.aiModel || "meta/llama-4-scout";
  const promptText = input.aiPrompt || "";

  if (!promptText || promptText.trim() === "") {
    return {
      success: false,
      error: "Prompt is required for text generation",
    };
  }

  const modelString = getModelString(modelId);

  try {
    const gateway = createGateway({
      apiKey,
    });

    if (input.aiFormat === "object" && input.aiSchema) {
      const schema = JSON.parse(input.aiSchema) as SchemaField[];
      const zodSchema = buildZodSchema(schema);

      const { object } = await generateObject({
        model: gateway(modelString),
        prompt: promptText,
        schema: zodSchema,
      });

      return { success: true, object };
    }

    const { text } = await generateText({
      model: gateway(modelString),
      prompt: promptText,
    });

    return { success: true, text };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Text generation failed: \${message}\`,
    };
  }
}`,

  "ai-gateway/generate-image": `import type { ImageModelV2 } from "@ai-sdk/provider";
import {
  createGateway,
  experimental_generateImage as generateImage,
} from "ai";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateImageResult =
  | { success: true; base64: string }
  | { success: false; error: string };

export type GenerateImageCoreInput = {
  imageModel: ImageModelV2;
  imagePrompt: string;
};

export async function generateImageStep(input: GenerateImageCoreInput): Promise<GenerateImageResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const gateway = createGateway({
      apiKey,
    });

    // biome-ignore lint/suspicious/noExplicitAny: AI gateway model ID is dynamic
    const modelId = (input.imageModel ?? "google/imagen-4.0-generate") as any;
    const result = await generateImage({
      model: gateway.imageModel(modelId),
      prompt: input.imagePrompt,
      size: "1024x1024",
    });

    if (!result.image) {
      return {
        success: false,
        error: "Failed to generate image: No image returned",
      };
    }

    const base64 = result.image.base64;

    return { success: true, base64 };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Image generation failed: \${message}\`,
    };
  }
}`,

  "clerk/get-user": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetUserResult =
  | { success: true; user: ClerkUser }
  | { success: false; error: string };

export type ClerkGetUserCoreInput = {
  userId: string;
};

export async function clerkGetUserStep(input: ClerkGetUserCoreInput): Promise<GetUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error:
        "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: "User ID is required.",
    };
  }

  try {
    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${input.userId}\`,
      {
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
      }
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return {
        success: false,
        error:
          error.errors?.[0]?.message || \`Failed to get user: \${response.status}\`,
      };
    }

    const user = await response.json();
    return { success: true, user };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to get user: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "clerk/create-user": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateUserResult =
  | { success: true; user: ClerkUser }
  | { success: false; error: string };

export type ClerkCreateUserCoreInput = {
  emailAddress: string;
  firstName?: string;
  lastName?: string;
  password?: string;
  publicMetadata?: string;
  privateMetadata?: string;
};

export async function clerkCreateUserStep(input: ClerkCreateUserCoreInput): Promise<CreateUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error:
        "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.emailAddress) {
    return {
      success: false,
      error: "Email address is required.",
    };
  }

  try {
    // Build the request body
    const body: Record<string, unknown> = {
      email_address: [input.emailAddress],
    };

    if (input.firstName) {
      body.first_name = input.firstName;
    }
    if (input.lastName) {
      body.last_name = input.lastName;
    }
    if (input.password) {
      body.password = input.password;
    }
    if (input.publicMetadata) {
      try {
        body.public_metadata = JSON.parse(input.publicMetadata);
      } catch {
        body.public_metadata = input.publicMetadata;
      }
    }
    if (input.privateMetadata) {
      try {
        body.private_metadata = JSON.parse(input.privateMetadata);
      } catch {
        body.private_metadata = input.privateMetadata;
      }
    }

    const response = await fetch("https://api.clerk.com/v1/users", {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${secretKey}\`,
        "Content-Type": "application/json",
        "User-Agent": "workflow-builder.dev",
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return {
        success: false,
        error:
          error.errors?.[0]?.message ||
          \`Failed to create user: \${response.status}\`,
      };
    }

    const user = await response.json();
    return { success: true, user };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create user: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "clerk/update-user": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type UpdateUserResult =
  | { success: true; user: ClerkUser }
  | { success: false; error: string };

export type ClerkUpdateUserCoreInput = {
  userId: string;
  firstName?: string;
  lastName?: string;
  publicMetadata?: string;
  privateMetadata?: string;
};

export async function clerkUpdateUserStep(input: ClerkUpdateUserCoreInput): Promise<UpdateUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error:
        "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: "User ID is required.",
    };
  }

  try {
    // Build the request body
    const body: Record<string, unknown> = {};

    if (input.firstName !== undefined) {
      body.first_name = input.firstName;
    }
    if (input.lastName !== undefined) {
      body.last_name = input.lastName;
    }
    if (input.publicMetadata) {
      try {
        body.public_metadata = JSON.parse(input.publicMetadata);
      } catch {
        body.public_metadata = input.publicMetadata;
      }
    }
    if (input.privateMetadata) {
      try {
        body.private_metadata = JSON.parse(input.privateMetadata);
      } catch {
        body.private_metadata = input.privateMetadata;
      }
    }

    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${input.userId}\`,
      {
        method: "PATCH",
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
        body: JSON.stringify(body),
      }
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return {
        success: false,
        error:
          error.errors?.[0]?.message ||
          \`Failed to update user: \${response.status}\`,
      };
    }

    const user = await response.json();
    return { success: true, user };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to update user: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "clerk/delete-user": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type DeleteUserResult =
  | { success: true; deleted: boolean }
  | { success: false; error: string };

export type ClerkDeleteUserCoreInput = {
  userId: string;
};

export async function clerkDeleteUserStep(input: ClerkDeleteUserCoreInput): Promise<DeleteUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error:
        "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: "User ID is required.",
    };
  }

  try {
    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${input.userId}\`,
      {
        method: "DELETE",
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
      }
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return {
        success: false,
        error:
          error.errors?.[0]?.message ||
          \`Failed to delete user: \${response.status}\`,
      };
    }

    return { success: true, deleted: true };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to delete user: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "firecrawl/scrape": `import FirecrawlApp from "@mendable/firecrawl-js";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ScrapeResult = {
  markdown?: string;
  metadata?: Record<string, unknown>;
};

export type FirecrawlScrapeCoreInput = {
  url: string;
  formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
};

export async function firecrawlScrapeStep(input: FirecrawlScrapeCoreInput): Promise<ScrapeResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const firecrawl = new FirecrawlApp({ apiKey });
    const result = await firecrawl.scrape(input.url, {
      formats: input.formats || ["markdown"],
    });

    return {
      markdown: result.markdown,
      metadata: result.metadata,
    };
  } catch (error) {
    throw new Error(\`Failed to scrape: \${getErrorMessage(error)}\`);
  }
}`,

  "firecrawl/search": `import FirecrawlApp from "@mendable/firecrawl-js";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SearchResult = {
  web?: unknown[];
};

export type FirecrawlSearchCoreInput = {
  query: string;
  limit?: number;
  scrapeOptions?: {
    formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
  };
};

export async function firecrawlSearchStep(input: FirecrawlSearchCoreInput): Promise<SearchResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const firecrawl = new FirecrawlApp({ apiKey });
    const result = await firecrawl.search(input.query, {
      limit: input.limit ? Number(input.limit) : undefined,
      scrapeOptions: input.scrapeOptions,
    });

    return {
      web: result.web,
    };
  } catch (error) {
    throw new Error(\`Failed to search: \${getErrorMessage(error)}\`);
  }
}`,

  "linear/create-ticket": `import { LinearClient } from "@linear/sdk";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateTicketResult =
  | { success: true; id: string; url: string; title: string }
  | { success: false; error: string };

export type CreateTicketCoreInput = {
  ticketTitle: string;
  ticketDescription: string;
};

export async function createTicketStep(input: CreateTicketCoreInput): Promise<CreateTicketResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
const apiKey = credentials.LINEAR_API_KEY;
  const teamId = credentials.LINEAR_TEAM_ID;

  if (!apiKey) {
    return {
      success: false,
      error:
        "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const linear = new LinearClient({ apiKey });

    let targetTeamId = teamId;
    if (!targetTeamId) {
      const teams = await linear.teams();
      const firstTeam = teams.nodes[0];
      if (!firstTeam) {
        return {
          success: false,
          error: "No teams found in Linear workspace",
        };
      }
      targetTeamId = firstTeam.id;
    }

    const issuePayload = await linear.createIssue({
      title: input.ticketTitle,
      description: input.ticketDescription,
      teamId: targetTeamId,
    });

    const issue = await issuePayload.issue;

    if (!issue) {
      return {
        success: false,
        error: "Failed to create issue",
      };
    }

    return {
      success: true,
      id: issue.id,
      url: issue.url,
      title: issue.title,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create ticket: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "linear/find-issues": `import { LinearClient } from "@linear/sdk";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type FindIssuesResult =
  | { success: true; issues: LinearIssue[]; count: number }
  | { success: false; error: string };

export type FindIssuesCoreInput = {
  linearAssigneeId?: string;
  linearTeamId?: string;
  linearStatus?: string;
  linearLabel?: string;
};

export async function findIssuesStep(input: FindIssuesCoreInput): Promise<FindIssuesResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
const apiKey = credentials.LINEAR_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const linear = new LinearClient({ apiKey });

    const filter: Record<string, unknown> = {};

    if (input.linearAssigneeId) {
      filter.assignee = { id: { eq: input.linearAssigneeId } };
    }

    if (input.linearTeamId) {
      filter.team = { id: { eq: input.linearTeamId } };
    }

    if (input.linearStatus && input.linearStatus !== "any") {
      filter.state = { name: { eqIgnoreCase: input.linearStatus } };
    }

    if (input.linearLabel) {
      filter.labels = { name: { eqIgnoreCase: input.linearLabel } };
    }

    const issues = await linear.issues({ filter });

    const mappedIssues: LinearIssue[] = await Promise.all(
      issues.nodes.map(async (issue) => {
        const state = await issue.state;
        return {
          id: issue.id,
          title: issue.title,
          url: issue.url,
          state: state?.name || "Unknown",
          priority: issue.priority,
          assigneeId: issue.assigneeId || undefined,
        };
      })
    );

    return {
      success: true,
      issues: mappedIssues,
      count: mappedIssues.length,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to find issues: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "resend/send-email": `import { Resend } from "resend";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendEmailResult =
  | { success: true; id: string }
  | { success: false; error: string };

export type SendEmailCoreInput = {
  emailFrom?: string;
  emailTo: string;
  emailSubject: string;
  emailBody: string;
  emailCc?: string;
  emailBcc?: string;
  emailReplyTo?: string;
  emailScheduledAt?: string;
  emailTopicId?: string;
  idempotencyKey?: string;
};

export async function sendEmailStep(input: SendEmailCoreInput): Promise<SendEmailResult> {
  "use step";
  const credentials = await fetchCredentials("resend");
const apiKey = credentials.RESEND_API_KEY;
  const fromEmail = credentials.RESEND_FROM_EMAIL;

  if (!apiKey) {
    return {
      success: false,
      error:
        "RESEND_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const senderEmail = input.emailFrom || fromEmail;

  if (!senderEmail) {
    return {
      success: false,
      error:
        "No sender is configured. Please add it in the action or in Project Integrations.",
    };
  }

  try {
    const resend = new Resend(apiKey);

    const result = await resend.emails.send(
      {
        from: senderEmail,
        to: input.emailTo,
        subject: input.emailSubject,
        text: input.emailBody,
        ...(input.emailCc && { cc: input.emailCc }),
        ...(input.emailBcc && { bcc: input.emailBcc }),
        ...(input.emailReplyTo && { replyTo: input.emailReplyTo }),
        ...(input.emailScheduledAt && { scheduledAt: input.emailScheduledAt }),
        ...(input.emailTopicId && { topicId: input.emailTopicId }),
      },
      input.idempotencyKey ? { idempotencyKey: input.idempotencyKey } : undefined
    );

    if (result.error) {
      return {
        success: false,
        error: result.error.message || "Failed to send email",
      };
    }

    return { success: true, id: result.data?.id || "" };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to send email: \${message}\`,
    };
  }
}`,

  "slack/send-message": `import { WebClient } from "@slack/web-api";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendSlackMessageResult =
  | { success: true; ts: string; channel: string }
  | { success: false; error: string };

export type SendSlackMessageCoreInput = {
  slackChannel: string;
  slackMessage: string;
};

export async function sendSlackMessageStep(input: SendSlackMessageCoreInput): Promise<SendSlackMessageResult> {
  "use step";
  const credentials = await fetchCredentials("slack");
const apiKey = credentials.SLACK_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "SLACK_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const slack = new WebClient(apiKey);

    const result = await slack.chat.postMessage({
      channel: input.slackChannel,
      text: input.slackMessage,
    });

    if (!result.ok) {
      return {
        success: false,
        error: result.error || "Failed to send Slack message",
      };
    }

    return {
      success: true,
      ts: result.ts || "",
      channel: result.channel || "",
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send Slack message: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "superagent/guard": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GuardResult = {
  classification: GuardClassification;
  violationTypes: string[];
  cweCodes: string[];
  reasoning?: string;
};

export type SuperagentGuardCoreInput = {
  text: string;
};

export async function superagentGuardStep(input: SuperagentGuardCoreInput): Promise<GuardResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const response = await fetch("https://app.superagent.sh/api/guard", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        text: input.text,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Guard API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];
    const content = choice?.message?.content;

    if (!content || typeof content !== "object") {
      throw new Error(
        "Invalid Guard API response: missing or invalid content structure"
      );
    }

    const classification = content.classification;
    if (
      !classification ||
      (classification !== "allow" && classification !== "block")
    ) {
      throw new Error(
        \`Invalid Guard API response: missing or invalid classification (received: \${JSON.stringify(classification)})\`
      );
    }

    return {
      classification,
      violationTypes: content?.violation_types || [],
      cweCodes: content?.cwe_codes || [],
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to analyze text: \${getErrorMessage(error)}\`);
  }
}`,

  "superagent/redact": `
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type RedactResult = {
  redactedText: string;
  reasoning?: string;
};

export type SuperagentRedactCoreInput = {
  text: string;
  entities?: string[] | string;
};

export async function superagentRedactStep(input: SuperagentRedactCoreInput): Promise<RedactResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const body: { text: string; entities?: string[] } = {
      text: input.text,
    };

    if (input.entities) {
      let entitiesArray: string[];

      if (typeof input.entities === "string") {
        entitiesArray = input.entities.split(",").map((e) => e.trim());
      } else if (Array.isArray(input.entities)) {
        entitiesArray = input.entities.map((e) => String(e).trim());
      } else {
        entitiesArray = [];
      }

      const validEntities = entitiesArray.filter((e) => e.length > 0);

      if (validEntities.length > 0) {
        body.entities = validEntities;
      }
    }

    const response = await fetch("https://app.superagent.sh/api/redact", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Redact API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];

    return {
      redactedText: choice?.message?.content || input.text,
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to redact text: \${getErrorMessage(error)}\`);
  }
}`,

  "v0/create-chat": `import { createClient, type ChatsCreateResponse } from "v0-sdk";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateChatResult =
  | { success: true; chatId: string; url: string; demoUrl?: string }
  | { success: false; error: string };

export type CreateChatCoreInput = {
  message: string;
  system?: string;
};

export async function createChatStep(input: CreateChatCoreInput): Promise<CreateChatResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.create({
      message: input.message,
      system: input.system,
    })) as ChatsCreateResponse;

    return {
      success: true,
      chatId: result.id,
      url: result.webUrl,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create chat: \${getErrorMessage(error)}\`,
    };
  }
}`,

  "v0/send-message": `import { createClient, type ChatsSendMessageResponse } from "v0-sdk";
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendMessageResult =
  | { success: true; chatId: string; demoUrl?: string }
  | { success: false; error: string };

export type SendMessageCoreInput = {
  chatId: string;
  message: string;
};

export async function sendMessageStep(input: SendMessageCoreInput): Promise<SendMessageResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.sendMessage({
      chatId: input.chatId,
      message: input.message,
    })) as ChatsSendMessageResponse;

    return {
      success: true,
      chatId: result.id,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send message: \${getErrorMessage(error)}\`,
    };
  }
}`,
};

/**
 * Get the auto-generated codegen template for an action
 */
export function getAutoGeneratedTemplate(actionId: string): string | undefined {
  return AUTO_GENERATED_TEMPLATES[actionId];
}
