/**
 * Codegen Registry (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * Contains auto-generated codegen templates for steps with stepHandler.
 * These templates are used when exporting workflows to standalone projects.
 *
 * Generated templates: 18
 */

/**
 * Auto-generated codegen templates
 * Maps action IDs to their generated export code templates
 */
export const AUTO_GENERATED_TEMPLATES: Record<string, string> = {
  "ai-gateway/generate-text": `import { createGateway, generateObject, generateText } from "ai";
import { z } from "zod";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateTextResult =
  | { success: true; text: string }
  | { success: true; object: Record<string, unknown> }
  | { success: false; error: string };

export type GenerateTextCoreInput = {
  aiModel?: string;
  aiPrompt?: string;
  aiFormat?: string;
  aiSchema?: string;
};

export async function generateTextStep(
  input: GenerateTextCoreInput,
): Promise<GenerateTextResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
  const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const modelId = input.aiModel || "meta/llama-4-scout";
  const promptText = input.aiPrompt || "";

  if (!promptText || promptText.trim() === "") {
    return {
      success: false,
      error: "Prompt is required for text generation",
    };
  }

  const modelString = getModelString(modelId);

  try {
    const gateway = createGateway({
      apiKey,
    });

    if (input.aiFormat === "object" && input.aiSchema) {
      const schema = JSON.parse(input.aiSchema) as SchemaField[];
      const zodSchema = buildZodSchema(schema);

      const { object } = await generateObject({
        model: gateway(modelString),
        prompt: promptText,
        schema: zodSchema,
      });

      return { success: true, object };
    }

    const { text } = await generateText({
      model: gateway(modelString),
      prompt: promptText,
    });

    return { success: true, text };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Text generation failed: \${message}\`,
    };
  }
}
`,

  "ai-gateway/generate-image": `import type { ImageModelV2 } from "@ai-sdk/provider";
import { createGateway, experimental_generateImage as generateImage } from "ai";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateImageResult =
  | { success: true; base64: string }
  | { success: false; error: string };

export type GenerateImageCoreInput = {
  imageModel: ImageModelV2;
  imagePrompt: string;
};

export async function generateImageStep(
  input: GenerateImageCoreInput,
): Promise<GenerateImageResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
  const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const gateway = createGateway({
      apiKey,
    });

    // biome-ignore lint/suspicious/noExplicitAny: AI gateway model ID is dynamic
    const modelId = (input.imageModel ?? "google/imagen-4.0-generate") as any;
    const result = await generateImage({
      model: gateway.imageModel(modelId),
      prompt: input.imagePrompt,
      size: "1024x1024",
    });

    if (!result.image) {
      return {
        success: false,
        error: "Failed to generate image: No image returned",
      };
    }

    const base64 = result.image.base64;

    return { success: true, base64 };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Image generation failed: \${message}\`,
    };
  }
}
`,

  "blob/put": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type PutBlobResult =
  | { success: true; url: string; downloadUrl: string; pathname: string }
  | { success: false; error: string };

export type PutBlobCoreInput = {
  pathname: string;
  body: string;
  contentType?: string;
  access?: string;
  addRandomSuffix?: string;
};

export async function putBlobStep(
  input: PutBlobCoreInput,
): Promise<PutBlobResult> {
  "use step";
  const credentials = await fetchCredentials("blob");
  const token = credentials.BLOB_READ_WRITE_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "BLOB_READ_WRITE_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.pathname) {
    return {
      success: false,
      error: "Pathname is required",
    };
  }

  if (!input.body) {
    return {
      success: false,
      error: "Content body is required",
    };
  }

  try {
    const url = new URL(\`/\${input.pathname}\`, BLOB_API_URL);

    // Add query parameters
    const addRandomSuffix = input.addRandomSuffix !== "false";
    if (!addRandomSuffix) {
      url.searchParams.set("addRandomSuffix", "false");
    }

    const headers: Record<string, string> = {
      Authorization: \`Bearer \${token}\`,
      "x-api-version": "7",
    };

    if (input.contentType) {
      headers["x-content-type"] = input.contentType;
    }

    const response = await fetch(url.toString(), {
      method: "PUT",
      headers,
      body: input.body,
    });

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage: string;
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.error?.message || errorText;
      } catch {
        errorMessage = errorText || \`HTTP \${response.status}\`;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }

    const data = (await response.json()) as PutBlobResponse;
    return {
      success: true,
      url: data.url,
      downloadUrl: data.downloadUrl,
      pathname: data.pathname,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to upload blob: \${message}\`,
    };
  }
}
`,

  "blob/list": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ListBlobsResult =
  | {
      success: true;
      blobs: BlobItem[];
      cursor?: string;
      hasMore: boolean;
    }
  | { success: false; error: string };

export type ListBlobsCoreInput = {
  prefix?: string;
  limit?: number;
  cursor?: string;
};

export async function listBlobsStep(
  input: ListBlobsCoreInput,
): Promise<ListBlobsResult> {
  "use step";
  const credentials = await fetchCredentials("blob");
  const token = credentials.BLOB_READ_WRITE_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "BLOB_READ_WRITE_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const url = new URL(BLOB_API_URL);

    if (input.prefix) {
      url.searchParams.set("prefix", input.prefix);
    }

    if (input.limit) {
      url.searchParams.set("limit", String(input.limit));
    }

    if (input.cursor) {
      url.searchParams.set("cursor", input.cursor);
    }

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        Authorization: \`Bearer \${token}\`,
        "x-api-version": "7",
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage: string;
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.error?.message || errorText;
      } catch {
        errorMessage = errorText || \`HTTP \${response.status}\`;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }

    const data = (await response.json()) as ListBlobsResponse;
    return {
      success: true,
      blobs: data.blobs,
      cursor: data.cursor,
      hasMore: data.hasMore,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to list blobs: \${message}\`,
    };
  }
}
`,

  "firecrawl/scrape": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ScrapeResult = {
  markdown?: string;
  metadata?: Record<string, unknown>;
};

export type FirecrawlScrapeCoreInput = {
  url: string;
  formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
};

export async function firecrawlScrapeStep(
  input: FirecrawlScrapeCoreInput,
): Promise<ScrapeResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
  const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const response = await fetch(\`\${FIRECRAWL_API_URL}/scrape\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        url: input.url,
        formats: input.formats || ["markdown"],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(\`HTTP \${response.status}: \${errorText}\`);
    }

    const result = (await response.json()) as FirecrawlScrapeResponse;

    if (!result.success) {
      throw new Error(result.error || "Scrape failed");
    }

    return {
      markdown: result.data?.markdown,
      metadata: result.data?.metadata,
    };
  } catch (error) {
    throw new Error(\`Failed to scrape: \${getErrorMessage(error)}\`);
  }
}
`,

  "firecrawl/search": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SearchResult = {
  data?: unknown[];
};

export type FirecrawlSearchCoreInput = {
  query: string;
  limit?: number;
  scrapeOptions?: {
    formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
  };
};

export async function firecrawlSearchStep(
  input: FirecrawlSearchCoreInput,
): Promise<SearchResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
  const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const response = await fetch(\`\${FIRECRAWL_API_URL}/search\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        query: input.query,
        limit: input.limit ? Number(input.limit) : undefined,
        scrapeOptions: input.scrapeOptions,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(\`HTTP \${response.status}: \${errorText}\`);
    }

    const result = (await response.json()) as FirecrawlSearchResponse;

    if (!result.success) {
      throw new Error(result.error || "Search failed");
    }

    return {
      data: result.data,
    };
  } catch (error) {
    throw new Error(\`Failed to search: \${getErrorMessage(error)}\`);
  }
}
`,

  "linear/create-ticket": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateTicketResult =
  | { success: true; id: string; url: string; title: string }
  | { success: false; error: string };

export type CreateTicketCoreInput = {
  ticketTitle: string;
  ticketDescription: string;
};

export async function createTicketStep(
  input: CreateTicketCoreInput,
): Promise<CreateTicketResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
  const apiKey = credentials.LINEAR_API_KEY;
  const teamId = credentials.LINEAR_TEAM_ID;

  if (!apiKey) {
    return {
      success: false,
      error:
        "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    let targetTeamId = teamId;

    if (!targetTeamId) {
      const teamsResult = await linearQuery<TeamsQueryResponse>(
        apiKey,
        \`query { teams { nodes { id name } } }\`,
      );

      if (teamsResult.errors?.length) {
        return {
          success: false,
          error: teamsResult.errors[0].message,
        };
      }

      const firstTeam = teamsResult.data?.teams.nodes[0];
      if (!firstTeam) {
        return {
          success: false,
          error: "No teams found in Linear workspace",
        };
      }
      targetTeamId = firstTeam.id;
    }

    const createResult = await linearQuery<CreateIssueMutationResponse>(
      apiKey,
      \`mutation CreateIssue($title: String!, $description: String, $teamId: String!) {
        issueCreate(input: { title: $title, description: $description, teamId: $teamId }) {
          success
          issue {
            id
            title
            url
          }
        }
      }\`,
      {
        title: input.ticketTitle,
        description: input.ticketDescription,
        teamId: targetTeamId,
      },
    );

    if (createResult.errors?.length) {
      return {
        success: false,
        error: createResult.errors[0].message,
      };
    }

    const issue = createResult.data?.issueCreate.issue;
    if (!issue) {
      return {
        success: false,
        error: "Failed to create issue",
      };
    }

    return {
      success: true,
      id: issue.id,
      url: issue.url,
      title: issue.title,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create ticket: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "linear/find-issues": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type FindIssuesResult =
  | { success: true; issues: LinearIssue[]; count: number }
  | { success: false; error: string };

export type FindIssuesCoreInput = {
  linearAssigneeId?: string;
  linearTeamId?: string;
  linearStatus?: string;
  linearLabel?: string;
};

export async function findIssuesStep(
  input: FindIssuesCoreInput,
): Promise<FindIssuesResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
  const apiKey = credentials.LINEAR_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    // Build filter object for Linear's GraphQL API
    const filter: Record<string, unknown> = {};

    if (input.linearAssigneeId) {
      filter.assignee = { id: { eq: input.linearAssigneeId } };
    }

    if (input.linearTeamId) {
      filter.team = { id: { eq: input.linearTeamId } };
    }

    if (input.linearStatus && input.linearStatus !== "any") {
      filter.state = { name: { eqIgnoreCase: input.linearStatus } };
    }

    if (input.linearLabel) {
      filter.labels = { name: { eqIgnoreCase: input.linearLabel } };
    }

    const result = await linearQuery<IssuesQueryResponse>(
      apiKey,
      \`query FindIssues($filter: IssueFilter) {
        issues(filter: $filter) {
          nodes {
            id
            title
            url
            priority
            assigneeId
            state {
              name
            }
          }
        }
      }\`,
      { filter: Object.keys(filter).length > 0 ? filter : undefined },
    );

    if (result.errors?.length) {
      return {
        success: false,
        error: result.errors[0].message,
      };
    }

    const mappedIssues: LinearIssue[] = (result.data?.issues.nodes || []).map(
      (issue) => ({
        id: issue.id,
        title: issue.title,
        url: issue.url,
        state: issue.state?.name || "Unknown",
        priority: issue.priority,
        assigneeId: issue.assigneeId || undefined,
      }),
    );

    return {
      success: true,
      issues: mappedIssues,
      count: mappedIssues.length,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to find issues: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "resend/send-email": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendEmailResult =
  | { success: true; id: string }
  | { success: false; error: string };

export type SendEmailCoreInput = {
  emailFrom?: string;
  emailTo: string;
  emailSubject: string;
  emailBody: string;
  emailCc?: string;
  emailBcc?: string;
  emailReplyTo?: string;
  emailScheduledAt?: string;
  emailTopicId?: string;
  idempotencyKey?: string;
};

export async function sendEmailStep(
  input: SendEmailCoreInput,
): Promise<SendEmailResult> {
  "use step";
  const credentials = await fetchCredentials("resend");
  const apiKey = credentials.RESEND_API_KEY;
  const fromEmail = credentials.RESEND_FROM_EMAIL;

  if (!apiKey) {
    return {
      success: false,
      error:
        "RESEND_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const senderEmail = input.emailFrom || fromEmail;

  if (!senderEmail) {
    return {
      success: false,
      error:
        "No sender is configured. Please add it in the action or in Project Integrations.",
    };
  }

  try {
    const headers: Record<string, string> = {
      Authorization: \`Bearer \${apiKey}\`,
      "Content-Type": "application/json",
    };

    if (input.idempotencyKey) {
      headers["Idempotency-Key"] = input.idempotencyKey;
    }

    const response = await fetch(\`\${RESEND_API_URL}/emails\`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        from: senderEmail,
        to: input.emailTo,
        subject: input.emailSubject,
        text: input.emailBody,
        ...(input.emailCc && { cc: input.emailCc }),
        ...(input.emailBcc && { bcc: input.emailBcc }),
        ...(input.emailReplyTo && { reply_to: input.emailReplyTo }),
        ...(input.emailScheduledAt && { scheduled_at: input.emailScheduledAt }),
      }),
    });

    if (!response.ok) {
      const errorData = (await response.json()) as ResendErrorResponse;
      return {
        success: false,
        error:
          errorData.message || \`HTTP \${response.status}: Failed to send email\`,
      };
    }

    const data = (await response.json()) as ResendEmailResponse;
    return { success: true, id: data.id };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to send email: \${message}\`,
    };
  }
}
`,

  "slack/send-message": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendSlackMessageResult =
  | { success: true; ts: string; channel: string }
  | { success: false; error: string };

export type SendSlackMessageCoreInput = {
  slackChannel: string;
  slackMessage: string;
};

export async function sendSlackMessageStep(
  input: SendSlackMessageCoreInput,
): Promise<SendSlackMessageResult> {
  "use step";
  const credentials = await fetchCredentials("slack");
  const apiKey = credentials.SLACK_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "SLACK_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const response = await fetch(\`\${SLACK_API_URL}/chat.postMessage\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        channel: input.slackChannel,
        text: input.slackMessage,
      }),
    });

    if (!response.ok) {
      return {
        success: false,
        error: \`HTTP \${response.status}: Failed to send Slack message\`,
      };
    }

    const result = (await response.json()) as SlackPostMessageResponse;

    if (!result.ok) {
      return {
        success: false,
        error: result.error || "Failed to send Slack message",
      };
    }

    return {
      success: true,
      ts: result.ts || "",
      channel: result.channel || "",
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send Slack message: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "stripe/create-customer": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateCustomerResult =
  | { success: true; id: string; email: string }
  | { success: false; error: string };

export type CreateCustomerCoreInput = {
  email: string;
  name?: string;
  phone?: string;
  description?: string;
  metadata?: string;
};

export async function createCustomerStep(
  input: CreateCustomerCoreInput,
): Promise<CreateCustomerResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const params = new URLSearchParams();
    params.append("email", input.email);

    if (input.name) {
      params.append("name", input.name);
    }
    if (input.phone) {
      params.append("phone", input.phone);
    }
    if (input.description) {
      params.append("description", input.description);
    }
    if (input.metadata) {
      try {
        const metadataObj = JSON.parse(input.metadata) as Record<
          string,
          string
        >;
        for (const [key, value] of Object.entries(metadataObj)) {
          params.append(\`metadata[\${key}]\`, String(value));
        }
      } catch {
        return {
          success: false,
          error: "Invalid metadata JSON format",
        };
      }
    }

    const response = await fetch(\`\${STRIPE_API_URL}/customers\`, {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${apiKey}\`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorData = (await response.json()) as StripeErrorResponse;
      return {
        success: false,
        error:
          errorData.error?.message ||
          \`HTTP \${response.status}: Failed to create customer\`,
      };
    }

    const data = (await response.json()) as StripeCustomerResponse;
    return { success: true, id: data.id, email: data.email };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to create customer: \${message}\`,
    };
  }
}
`,

  "stripe/get-customer": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetCustomerResult =
  | {
      success: true;
      id: string;
      email: string;
      name: string | null;
      created: number;
    }
  | { success: false; error: string };

export type GetCustomerCoreInput = {
  customerId?: string;
  email?: string;
};

export async function getCustomerStep(
  input: GetCustomerCoreInput,
): Promise<GetCustomerResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.customerId && !input.email) {
    return {
      success: false,
      error: "Either Customer ID or Email is required",
    };
  }

  try {
    let customer: StripeCustomerResponse | null = null;

    if (input.customerId) {
      // Direct lookup by ID
      const response = await fetch(
        \`\${STRIPE_API_URL}/customers/\${input.customerId}\`,
        {
          method: "GET",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
          },
        },
      );

      if (!response.ok) {
        const errorData = (await response.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${response.status}: Failed to get customer\`,
        };
      }

      customer = (await response.json()) as StripeCustomerResponse;
    } else if (input.email) {
      // Search by email
      const params = new URLSearchParams();
      params.append("email", input.email);
      params.append("limit", "1");

      const response = await fetch(
        \`\${STRIPE_API_URL}/customers?\${params.toString()}\`,
        {
          method: "GET",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
          },
        },
      );

      if (!response.ok) {
        const errorData = (await response.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${response.status}: Failed to search customers\`,
        };
      }

      const data = (await response.json()) as StripeCustomerListResponse;
      if (data.data.length === 0) {
        return {
          success: false,
          error: \`No customer found with email: \${input.email}\`,
        };
      }
      customer = data.data[0];
    }

    if (!customer) {
      return {
        success: false,
        error: "Customer not found",
      };
    }

    return {
      success: true,
      id: customer.id,
      email: customer.email,
      name: customer.name,
      created: customer.created,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to get customer: \${message}\`,
    };
  }
}
`,

  "stripe/create-checkout-session": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateCheckoutSessionResult =
  | { success: true; id: string; url: string }
  | { success: false; error: string };

export type CreateCheckoutSessionCoreInput = {
  mode: "payment" | "subscription";
  priceId: string;
  quantity?: number;
  successUrl: string;
  cancelUrl: string;
  customerId?: string;
  customerEmail?: string;
  allowPromotionCodes?: string;
  metadata?: string;
};

export async function createCheckoutSessionStep(
  input: CreateCheckoutSessionCoreInput,
): Promise<CreateCheckoutSessionResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const params = new URLSearchParams();
    params.append("mode", input.mode);
    params.append("line_items[0][price]", input.priceId);
    params.append("line_items[0][quantity]", String(input.quantity || 1));
    params.append("success_url", input.successUrl);
    params.append("cancel_url", input.cancelUrl);

    if (input.customerId) {
      params.append("customer", input.customerId);
    }
    if (input.customerEmail && !input.customerId) {
      params.append("customer_email", input.customerEmail);
    }
    if (input.allowPromotionCodes === "true") {
      params.append("allow_promotion_codes", "true");
    }
    if (input.metadata) {
      try {
        const metadataObj = JSON.parse(input.metadata) as Record<
          string,
          string
        >;
        for (const [key, value] of Object.entries(metadataObj)) {
          params.append(\`metadata[\${key}]\`, String(value));
        }
      } catch {
        return {
          success: false,
          error: "Invalid metadata JSON format",
        };
      }
    }

    const response = await fetch(\`\${STRIPE_API_URL}/checkout/sessions\`, {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${apiKey}\`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorData = (await response.json()) as StripeErrorResponse;
      return {
        success: false,
        error:
          errorData.error?.message ||
          \`HTTP \${response.status}: Failed to create checkout session\`,
      };
    }

    const data = (await response.json()) as StripeCheckoutSessionResponse;
    return { success: true, id: data.id, url: data.url };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to create checkout session: \${message}\`,
    };
  }
}
`,

  "stripe/create-invoice": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateInvoiceResult =
  | {
      success: true;
      id: string;
      number: string | null;
      hostedInvoiceUrl: string | null;
      status: string;
    }
  | { success: false; error: string };

export type CreateInvoiceCoreInput = {
  customerId: string;
  description?: string;
  lineItems: string;
  daysUntilDue?: number;
  autoAdvance?: string;
  collectionMethod?: "send_invoice" | "charge_automatically";
  metadata?: string;
};

export async function createInvoiceStep(
  input: CreateInvoiceCoreInput,
): Promise<CreateInvoiceResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  let lineItems: LineItem[];
  try {
    lineItems = JSON.parse(input.lineItems) as LineItem[];
    if (!Array.isArray(lineItems) || lineItems.length === 0) {
      return {
        success: false,
        error: "Line items must be a non-empty JSON array",
      };
    }
  } catch {
    return {
      success: false,
      error:
        'Invalid line items JSON format. Expected: [{"description": "Item", "amount": 1000, "quantity": 1}]',
    };
  }

  try {
    // Step 1: Create the invoice
    const invoiceParams = new URLSearchParams();
    invoiceParams.append("customer", input.customerId);
    invoiceParams.append(
      "collection_method",
      input.collectionMethod || "send_invoice",
    );
    invoiceParams.append("days_until_due", String(input.daysUntilDue || 30));
    invoiceParams.append(
      "auto_advance",
      input.autoAdvance === "false" ? "false" : "true",
    );

    if (input.description) {
      invoiceParams.append("description", input.description);
    }
    if (input.metadata) {
      try {
        const metadataObj = JSON.parse(input.metadata) as Record<
          string,
          string
        >;
        for (const [key, value] of Object.entries(metadataObj)) {
          invoiceParams.append(\`metadata[\${key}]\`, String(value));
        }
      } catch {
        return {
          success: false,
          error: "Invalid metadata JSON format",
        };
      }
    }

    const invoiceResponse = await fetch(\`\${STRIPE_API_URL}/invoices\`, {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${apiKey}\`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: invoiceParams.toString(),
    });

    if (!invoiceResponse.ok) {
      const errorData = (await invoiceResponse.json()) as StripeErrorResponse;
      return {
        success: false,
        error:
          errorData.error?.message ||
          \`HTTP \${invoiceResponse.status}: Failed to create invoice\`,
      };
    }

    const invoice = (await invoiceResponse.json()) as StripeInvoiceResponse;

    // Step 2: Add line items
    for (const item of lineItems) {
      const itemParams = new URLSearchParams();
      itemParams.append("invoice", invoice.id);
      itemParams.append("description", item.description);
      itemParams.append("quantity", String(item.quantity || 1));
      itemParams.append("unit_amount", String(item.amount));
      itemParams.append("currency", "usd");

      const itemResponse = await fetch(\`\${STRIPE_API_URL}/invoiceitems\`, {
        method: "POST",
        headers: {
          Authorization: \`Bearer \${apiKey}\`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: itemParams.toString(),
      });

      if (!itemResponse.ok) {
        const errorData = (await itemResponse.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${itemResponse.status}: Failed to add line item\`,
        };
      }
    }

    // Step 3: Finalize invoice if auto_advance is true
    let finalInvoice = invoice;
    if (input.autoAdvance !== "false") {
      const finalizeResponse = await fetch(
        \`\${STRIPE_API_URL}/invoices/\${invoice.id}/finalize\`,
        {
          method: "POST",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
            "Content-Type": "application/x-www-form-urlencoded",
          },
        },
      );

      if (!finalizeResponse.ok) {
        const errorData =
          (await finalizeResponse.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${finalizeResponse.status}: Failed to finalize invoice\`,
        };
      }

      finalInvoice = (await finalizeResponse.json()) as StripeInvoiceResponse;
    }

    return {
      success: true,
      id: finalInvoice.id,
      number: finalInvoice.number,
      hostedInvoiceUrl: finalInvoice.hosted_invoice_url,
      status: finalInvoice.status,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to create invoice: \${message}\`,
    };
  }
}
`,

  "superagent/guard": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GuardResult = {
  classification: GuardClassification;
  violationTypes: string[];
  cweCodes: string[];
  reasoning?: string;
};

export type SuperagentGuardCoreInput = {
  text: string;
};

export async function superagentGuardStep(
  input: SuperagentGuardCoreInput,
): Promise<GuardResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
  const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const response = await fetch("https://app.superagent.sh/api/guard", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        text: input.text,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Guard API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];
    const content = choice?.message?.content;

    if (!content || typeof content !== "object") {
      throw new Error(
        "Invalid Guard API response: missing or invalid content structure",
      );
    }

    const classification = content.classification;
    if (
      !classification ||
      (classification !== "allow" && classification !== "block")
    ) {
      throw new Error(
        \`Invalid Guard API response: missing or invalid classification (received: \${JSON.stringify(classification)})\`,
      );
    }

    return {
      classification,
      violationTypes: content?.violation_types || [],
      cweCodes: content?.cwe_codes || [],
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to analyze text: \${getErrorMessage(error)}\`);
  }
}
`,

  "superagent/redact": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type RedactResult = {
  redactedText: string;
  reasoning?: string;
};

export type SuperagentRedactCoreInput = {
  text: string;
  entities?: string[] | string;
};

export async function superagentRedactStep(
  input: SuperagentRedactCoreInput,
): Promise<RedactResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
  const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const body: { text: string; entities?: string[] } = {
      text: input.text,
    };

    if (input.entities) {
      let entitiesArray: string[];

      if (typeof input.entities === "string") {
        entitiesArray = input.entities.split(",").map((e) => e.trim());
      } else if (Array.isArray(input.entities)) {
        entitiesArray = input.entities.map((e) => String(e).trim());
      } else {
        entitiesArray = [];
      }

      const validEntities = entitiesArray.filter((e) => e.length > 0);

      if (validEntities.length > 0) {
        body.entities = validEntities;
      }
    }

    const response = await fetch("https://app.superagent.sh/api/redact", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Redact API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];

    return {
      redactedText: choice?.message?.content || input.text,
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to redact text: \${getErrorMessage(error)}\`);
  }
}
`,

  "v0/create-chat": `import { createClient, type ChatsCreateResponse } from "v0-sdk";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateChatResult =
  | { success: true; chatId: string; url: string; demoUrl?: string }
  | { success: false; error: string };

export type CreateChatCoreInput = {
  message: string;
  system?: string;
};

export async function createChatStep(
  input: CreateChatCoreInput,
): Promise<CreateChatResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
  const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.create({
      message: input.message,
      system: input.system,
    })) as ChatsCreateResponse;

    return {
      success: true,
      chatId: result.id,
      url: result.webUrl,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create chat: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "v0/send-message": `import { createClient, type ChatsSendMessageResponse } from "v0-sdk";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendMessageResult =
  | { success: true; chatId: string; demoUrl?: string }
  | { success: false; error: string };

export type SendMessageCoreInput = {
  chatId: string;
  message: string;
};

export async function sendMessageStep(
  input: SendMessageCoreInput,
): Promise<SendMessageResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
  const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.sendMessage({
      chatId: input.chatId,
      message: input.message,
    })) as ChatsSendMessageResponse;

    return {
      success: true,
      chatId: result.id,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send message: \${getErrorMessage(error)}\`,
    };
  }
}
`,
};

/**
 * Get the auto-generated codegen template for an action
 */
export function getAutoGeneratedTemplate(actionId: string): string | undefined {
  return AUTO_GENERATED_TEMPLATES[actionId];
}
